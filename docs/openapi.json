{
  "openapi": "3.1.0",
  "info": {
    "title": "NameGuard API",
    "description": "Welcome to NameGuard, a powerful tool developed by [NameHash Labs](https://namehashlabs.org) to identify and prevent malicious use of Ethereum Name Service (ENS) names.\n\n## Important Notes\n⚠️ Beta Version: Please be aware that NameGuard is currently in beta. We appreciate your feedback as we work towards a stable v1 release. Expect changes to the API to address community feedback and improve functionality.\n\n## Documentation\nThese documentation pages focus specifically on the NameGuard API. For information on the NameGuard Library, SDK, and UI Kit, please refer to the [NameGuard GitHub repository](https://github.com/namehash/nameguard).",
    "version": "v0.8-beta"
  },
  "paths": {
    "/inspect-name/{network_name}/{name}": {
      "get": {
        "tags": ["name"],
        "summary": "Inspect Name",
        "operationId": "inspect_name_get_inspect_name__network_name___name__get",
        "parameters": [
          {
            "name": "network_name",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/NetworkName"
            }
          },
          {
            "name": "name",
            "in": "path",
            "required": false,
            "schema": {
              "type": "string",
              "description": "**Name should be url-encoded (except when using the Swagger UI).**",
              "examples": ["vitalìk.eth"],
              "title": "Name"
            },
            "description": "**Name should be url-encoded (except when using the Swagger UI).**"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NameGuardReport"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          },
          "503": {
            "description": "Error while making request to ENS Subgraph.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExceptionResponse"
                }
              }
            }
          }
        }
      }
    },
    "/inspect-name": {
      "post": {
        "tags": ["name"],
        "summary": "Inspect Name",
        "operationId": "inspect_name_post_inspect_name_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InspectNameRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NameGuardReport"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          },
          "503": {
            "description": "Error while making request to ENS Subgraph.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExceptionResponse"
                }
              }
            }
          }
        }
      }
    },
    "/bulk-inspect-names": {
      "post": {
        "tags": ["name"],
        "summary": "Inspect Multiple Names",
        "operationId": "bulk_inspect_names_bulk_inspect_names_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BulkInspectNamesRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BulkNameGuardBulkReport"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          },
          "503": {
            "description": "Error while making request to ENS Subgraph.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExceptionResponse"
                }
              }
            }
          }
        }
      }
    },
    "/inspect-namehash/{network_name}/{namehash}": {
      "get": {
        "tags": ["namehash"],
        "summary": "Inspect Namehash GET",
        "operationId": "inspect_namehash_get_inspect_namehash__network_name___namehash__get",
        "parameters": [
          {
            "name": "network_name",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/NetworkName"
            }
          },
          {
            "name": "namehash",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Namehash should be a decimal or a hex (prefixed with 0x) string.",
              "examples": [
                "0xd48fd5598e605861cbd8e45419b41b83739bff52eaef0e283181bbe0a43a5b32"
              ],
              "title": "Namehash"
            },
            "description": "Namehash should be a decimal or a hex (prefixed with 0x) string."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NameGuardReport"
                }
              }
            }
          },
          "404": {
            "description": "Provided namehash could not be found in ENS Subgraph.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExceptionResponse"
                }
              }
            }
          },
          "422": {
            "description": "Provided namehash is not valid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExceptionResponse"
                }
              }
            }
          },
          "500": {
            "description": "Namehash calculated on the name returned from ENS Subgraph does not equal the input namehash.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExceptionResponse"
                }
              }
            }
          },
          "503": {
            "description": "Error while making request to ENS Subgraph.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExceptionResponse"
                }
              }
            }
          }
        }
      }
    },
    "/inspect-namehash": {
      "post": {
        "tags": ["namehash"],
        "summary": "Inspect Namehash",
        "operationId": "inspect_namehash_post_inspect_namehash_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InspectNamehashRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NameGuardReport"
                }
              }
            }
          },
          "404": {
            "description": "Provided namehash could not be found in ENS Subgraph.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExceptionResponse"
                }
              }
            }
          },
          "422": {
            "description": "Provided namehash is not valid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExceptionResponse"
                }
              }
            }
          },
          "500": {
            "description": "Namehash calculated on the name returned from ENS Subgraph does not equal the input namehash.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExceptionResponse"
                }
              }
            }
          },
          "503": {
            "description": "Error while making request to ENS Subgraph.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExceptionResponse"
                }
              }
            }
          }
        }
      }
    },
    "/inspect-labelhash/{network_name}/{labelhash}/{parent_name}": {
      "get": {
        "tags": ["labelhash"],
        "summary": "Inspect Labelhash GET",
        "operationId": "inspect_labelhash_get_inspect_labelhash__network_name___labelhash___parent_name__get",
        "parameters": [
          {
            "name": "network_name",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/NetworkName"
            }
          },
          {
            "name": "labelhash",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Labelhash should be a decimal or a hex (prefixed with 0x) string.",
              "examples": [
                "0x3276e4878615389906712b876ce1455b8f5d1c5ea3ffcf7a705e0d32fafae9c5"
              ],
              "title": "Labelhash"
            },
            "description": "Labelhash should be a decimal or a hex (prefixed with 0x) string."
          },
          {
            "name": "parent_name",
            "in": "path",
            "required": false,
            "schema": {
              "type": "string",
              "examples": ["eth"],
              "title": "Parent Name"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NameGuardReport"
                }
              }
            }
          },
          "404": {
            "description": "Provided namehash could not be found in ENS Subgraph.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExceptionResponse"
                }
              }
            }
          },
          "422": {
            "description": "Provided namehash is not valid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExceptionResponse"
                }
              }
            }
          },
          "500": {
            "description": "Namehash calculated on the name returned from ENS Subgraph does not equal the input namehash.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExceptionResponse"
                }
              }
            }
          },
          "503": {
            "description": "Error while making request to ENS Subgraph.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExceptionResponse"
                }
              }
            }
          }
        }
      }
    },
    "/inspect-labelhash": {
      "post": {
        "tags": ["labelhash"],
        "summary": "Inspect Labelhash",
        "operationId": "inspect_labelhash_post_inspect_labelhash_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InspectLabelhashRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NameGuardReport"
                }
              }
            }
          },
          "404": {
            "description": "Provided namehash could not be found in ENS Subgraph.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExceptionResponse"
                }
              }
            }
          },
          "422": {
            "description": "Provided namehash is not valid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExceptionResponse"
                }
              }
            }
          },
          "500": {
            "description": "Namehash calculated on the name returned from ENS Subgraph does not equal the input namehash.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExceptionResponse"
                }
              }
            }
          },
          "503": {
            "description": "Error while making request to ENS Subgraph.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExceptionResponse"
                }
              }
            }
          }
        }
      }
    },
    "/secure-primary-name/{network_name}/{address}": {
      "get": {
        "tags": ["secure_primary_name"],
        "summary": "Reverse lookup of Ethereum address to primary name",
        "operationId": "secure_primary_name_get_secure_primary_name__network_name___address__get",
        "parameters": [
          {
            "name": "address",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Address"
            }
          },
          {
            "name": "network_name",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/NetworkName"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SecurePrimaryNameResult"
                }
              }
            }
          },
          "422": {
            "description": "Provided Ethereum address is not valid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExceptionResponse"
                }
              }
            }
          },
          "503": {
            "description": "Error while making request to provider.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExceptionResponse"
                }
              }
            }
          }
        }
      }
    },
    "/fake-eth-name-check/{network_name}/{contract_address}/{token_id}": {
      "get": {
        "tags": ["fake-eth-name-check"],
        "summary": "Fake .eth ENS name check GET",
        "operationId": "fake_eth_name_check_get_fake_eth_name_check__network_name___contract_address___token_id__get",
        "parameters": [
          {
            "name": "network_name",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/NetworkName"
            }
          },
          {
            "name": "contract_address",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Contract address for the NFT contract (ERC721 and ERC1155 supported).",
              "examples": ["0x495f947276749ce646f68ac8c248420045cb7b5e"],
              "title": "Contract Address"
            },
            "description": "Contract address for the NFT contract (ERC721 and ERC1155 supported)."
          },
          {
            "name": "token_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID of the token (in hex or decimal format).",
              "examples": [
                "61995921128521442959106650131462633744885269624153038309795231243542768648193"
              ],
              "title": "Token Id"
            },
            "description": "The ID of the token (in hex or decimal format)."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FakeEthNameCheckResult"
                }
              }
            }
          },
          "422": {
            "description": "Provided Ethereum address is not valid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExceptionResponse"
                }
              }
            }
          },
          "503": {
            "description": "Error while making request to provider.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExceptionResponse"
                }
              }
            }
          }
        }
      }
    },
    "/fake-eth-name-check-fields": {
      "post": {
        "tags": ["fake-eth-name-check"],
        "summary": "Fake .eth ENS name check with fields",
        "operationId": "fake_eth_name_check_fields_post_fake_eth_name_check_fields_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FakeETHNameCheckFieldsRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FakeEthNameCheckResult"
                }
              }
            }
          },
          "422": {
            "description": "A field named 'title' is required within the list of fields",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExceptionResponse"
                }
              }
            }
          }
        }
      }
    },
    "/inspect-grapheme/{grapheme}": {
      "get": {
        "tags": ["grapheme"],
        "summary": "Inspect Grapheme GET",
        "operationId": "inspect_grapheme_get_inspect_grapheme__grapheme__get",
        "parameters": [
          {
            "name": "grapheme",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Grapheme to inspect. Should be url-encoded (except when using the Swagger UI).",
              "examples": ["v", "ń", "%F0%9F%98%B5"],
              "title": "Grapheme"
            },
            "description": "Grapheme to inspect. Should be url-encoded (except when using the Swagger UI)."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GraphemeGuardReport"
                }
              }
            }
          },
          "422": {
            "description": "The provided string is not a single grapheme.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExceptionResponse"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "BulkInspectNamesRequest": {
        "properties": {
          "names": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "maxItems": 250,
            "title": "Names",
            "examples": [["vitalìk.eth", "nick.eth"]]
          },
          "network_name": {
            "$ref": "#/components/schemas/NetworkName"
          }
        },
        "type": "object",
        "required": ["names", "network_name"],
        "title": "BulkInspectNamesRequest"
      },
      "BulkNameGuardBulkReport": {
        "properties": {
          "results": {
            "items": {
              "$ref": "#/components/schemas/ConsolidatedNameGuardReport"
            },
            "type": "array",
            "title": "Results"
          }
        },
        "type": "object",
        "required": ["results"],
        "title": "BulkNameGuardBulkReport",
        "description": "Bulk name analysis results."
      },
      "Check": {
        "type": "string",
        "enum": [
          "normalized",
          "confusables",
          "invisible",
          "typing_difficulty",
          "font_support",
          "mixed_scripts",
          "namewrapper_compatible",
          "punycode_compatible_label",
          "unknown_label",
          "impersonation_risk",
          "punycode_compatible_name",
          "namewrapper_fuses",
          "decentralized_name"
        ],
        "title": "Check",
        "description": "The type of a check.\n\nCommon:\n* `normalized`: A name/label/grapheme is ENSIP-15 normalized.\n\nGrapheme:\n* `confusables`: A grapheme is visually confusable.\n* `invisible`: A grapheme is invisible.\n* `typing_difficulty`: A grapheme is difficult to type.\n* `font_support`: A grapheme is not supported by common fonts.\n\nLabel:\n* `mixed_scripts`: A label contains multiple scripts.\n* `namewrapper_compatible`: TODO\n* `punycode_compatible_label`: A label is compatible with Punycode.\n* `unknown_label`: A label is unknown.\n\nName:\n* `impersonation_risk`: A name might be used for impersonation.\n* `punycode_compatible_name`: A name is compatible with Punycode.\n* `namewrapper_fuses`: The NameWrapper configuration of a name is safe.\n* `decentralized_name`: A name is decentralized."
      },
      "CheckStatus": {
        "type": "string",
        "enum": ["info", "pass", "skip", "warn", "alert"],
        "title": "CheckStatus",
        "description": "The status of a conducted check.\n\n* `skip`: This check was skipped because it was not applicable.\n* `info`: This check is informational only.\n* `pass`: This check passed.\n* `warn`: This check failed, this is a minor issue.\n* `alert`: This check failed, this is a major issue."
      },
      "ConfusableGuardReport": {
        "properties": {
          "rating": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Rating"
              }
            ],
            "examples": ["warn"]
          },
          "risk_count": {
            "type": "integer",
            "title": "Risk Count",
            "description": "The number of checks that have a status of `alert` or `warn`.",
            "examples": [2]
          },
          "highest_risk": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GenericCheckResult"
              },
              {
                "type": "null"
              }
            ],
            "description": "The check considered to be the highest risk. If no check has a status of `alert` or `warn`, this field is `null`."
          },
          "normalization": {
            "$ref": "#/components/schemas/GraphemeNormalization"
          },
          "grapheme": {
            "type": "string",
            "title": "Grapheme",
            "description": "The analyzed grapheme.",
            "examples": ["v"]
          },
          "grapheme_name": {
            "type": "string",
            "title": "Grapheme Name",
            "description": "The name of the grapheme.",
            "examples": ["Latin Small Letter V"]
          },
          "grapheme_type": {
            "type": "string",
            "title": "Grapheme Type",
            "description": "The type of the grapheme. If all characters in the grapheme have the same type, that type is returned. Otherwise, `special` is returned.\n* `simple_letter` - `[a-z]`\n* `simple_number` - `[0-9]`\n* `other_letter` - a letter (single-char grapheme) in any script that is not simple; `LC` class http://www.unicode.org/reports/tr44/#GC_Values_Table \n* `other_number` - a digit (single-char grapheme) in any script that is not simple; `N` class http://www.unicode.org/reports/tr44/#GC_Values_Table \n* `hyphen` - a hyphen\n* `dollarsign` - a dollar sign\n* `underscore` - an underscore\n* `emoji` - an emoji or emoji ZWJ sequence\n* `invisible` - zero width joiner or non-joiner\n* `special` - for any grapheme that doesn't match one of the other classifications or if characters have different types",
            "examples": ["simple_letter"]
          },
          "grapheme_script": {
            "type": "string",
            "title": "Grapheme Script",
            "description": "Script name of the grapheme computed from the script names of its characters.",
            "examples": ["Latin"]
          },
          "grapheme_description": {
            "type": "string",
            "title": "Grapheme Description",
            "description": "Description of the grapheme type.",
            "examples": ["A-Z letter"]
          },
          "is_canonical": {
            "type": "boolean",
            "title": "Is Canonical",
            "description": "Whether this confusable is canonical for the grapheme."
          },
          "title": {
            "type": "string",
            "title": "Title",
            "description": "A human-readable title based on the `rating`.",
            "readOnly": true
          },
          "subtitle": {
            "type": "string",
            "title": "Subtitle",
            "description": "A human-readable subtitle based on the `rating`.",
            "readOnly": true
          }
        },
        "type": "object",
        "required": [
          "rating",
          "risk_count",
          "highest_risk",
          "normalization",
          "grapheme",
          "grapheme_name",
          "grapheme_type",
          "grapheme_script",
          "grapheme_description",
          "is_canonical",
          "title",
          "subtitle"
        ],
        "title": "ConfusableGuardReport"
      },
      "ConsolidatedGraphemeGuardReport": {
        "properties": {
          "rating": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Rating"
              }
            ],
            "examples": ["warn"]
          },
          "risk_count": {
            "type": "integer",
            "title": "Risk Count",
            "description": "The number of checks that have a status of `alert` or `warn`.",
            "examples": [2]
          },
          "highest_risk": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GenericCheckResult"
              },
              {
                "type": "null"
              }
            ],
            "description": "The check considered to be the highest risk. If no check has a status of `alert` or `warn`, this field is `null`."
          },
          "normalization": {
            "$ref": "#/components/schemas/GraphemeNormalization"
          },
          "grapheme": {
            "type": "string",
            "title": "Grapheme",
            "description": "The analyzed grapheme.",
            "examples": ["v"]
          },
          "grapheme_name": {
            "type": "string",
            "title": "Grapheme Name",
            "description": "The name of the grapheme.",
            "examples": ["Latin Small Letter V"]
          },
          "grapheme_type": {
            "type": "string",
            "title": "Grapheme Type",
            "description": "The type of the grapheme. If all characters in the grapheme have the same type, that type is returned. Otherwise, `special` is returned.\n* `simple_letter` - `[a-z]`\n* `simple_number` - `[0-9]`\n* `other_letter` - a letter (single-char grapheme) in any script that is not simple; `LC` class http://www.unicode.org/reports/tr44/#GC_Values_Table \n* `other_number` - a digit (single-char grapheme) in any script that is not simple; `N` class http://www.unicode.org/reports/tr44/#GC_Values_Table \n* `hyphen` - a hyphen\n* `dollarsign` - a dollar sign\n* `underscore` - an underscore\n* `emoji` - an emoji or emoji ZWJ sequence\n* `invisible` - zero width joiner or non-joiner\n* `special` - for any grapheme that doesn't match one of the other classifications or if characters have different types",
            "examples": ["simple_letter"]
          },
          "grapheme_script": {
            "type": "string",
            "title": "Grapheme Script",
            "description": "Script name of the grapheme computed from the script names of its characters.",
            "examples": ["Latin"]
          },
          "grapheme_description": {
            "type": "string",
            "title": "Grapheme Description",
            "description": "Description of the grapheme type.",
            "examples": ["A-Z letter"]
          },
          "title": {
            "type": "string",
            "title": "Title",
            "description": "A human-readable title based on the `rating`.",
            "readOnly": true
          },
          "subtitle": {
            "type": "string",
            "title": "Subtitle",
            "description": "A human-readable subtitle based on the `rating`.",
            "readOnly": true
          }
        },
        "type": "object",
        "required": [
          "rating",
          "risk_count",
          "highest_risk",
          "normalization",
          "grapheme",
          "grapheme_name",
          "grapheme_type",
          "grapheme_script",
          "grapheme_description",
          "title",
          "subtitle"
        ],
        "title": "ConsolidatedGraphemeGuardReport",
        "description": "Grapheme analysis result."
      },
      "ConsolidatedNameGuardReport": {
        "properties": {
          "rating": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Rating"
              }
            ],
            "examples": ["warn"]
          },
          "risk_count": {
            "type": "integer",
            "title": "Risk Count",
            "description": "The number of checks that have a status of `alert` or `warn`.",
            "examples": [2]
          },
          "highest_risk": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GenericCheckResult"
              },
              {
                "type": "null"
              }
            ],
            "description": "The check considered to be the highest risk. If no check has a status of `alert` or `warn`, this field is `null`."
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "The analyzed name. Can contain labelhashes when some labels are unknown.",
            "examples": [
              "vitalìk.eth",
              "[af498306bb191650e8614d574b3687c104bc1cd7e07c522954326752c6882770].eth"
            ]
          },
          "namehash": {
            "type": "string",
            "title": "Namehash",
            "description": "The namehash of the name in hex format prefixed with `0x`.",
            "examples": [
              "0xd48fd5598e605861cbd8e45419b41b83739bff52eaef0e283181bbe0a43a5b32"
            ]
          },
          "normalization": {
            "$ref": "#/components/schemas/Normalization"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "description": "A human-readable title based on the `rating`.",
            "readOnly": true
          },
          "subtitle": {
            "type": "string",
            "title": "Subtitle",
            "description": "A human-readable subtitle based on the `rating`.",
            "readOnly": true
          },
          "beautiful_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Beautiful Name",
            "description": "Beautified version of `name`.",
            "readOnly": true
          }
        },
        "type": "object",
        "required": [
          "rating",
          "risk_count",
          "highest_risk",
          "name",
          "namehash",
          "normalization",
          "title",
          "subtitle",
          "beautiful_name"
        ],
        "title": "ConsolidatedNameGuardReport",
        "description": "Name analysis result without information about individual checks and labels."
      },
      "ExceptionResponse": {
        "properties": {
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "Human-readable description of the error.",
            "examples": ["This is a human-readable description of the error."]
          }
        },
        "type": "object",
        "required": ["detail"],
        "title": "ExceptionResponse"
      },
      "FakeETHNameCheckFieldsRequest": {
        "properties": {
          "network_name": {
            "$ref": "#/components/schemas/NetworkName"
          },
          "contract_address": {
            "type": "string",
            "title": "Contract Address",
            "description": "Contract address for the NFT contract (ERC721 and ERC1155 supported).",
            "examples": ["0x495f947276749ce646f68ac8c248420045cb7b5e"]
          },
          "token_id": {
            "type": "string",
            "title": "Token Id",
            "description": "The ID of the token (in hex or decimal format).",
            "examples": [
              "61995921128521442959106650131462633744885269624153038309795231243542768648193"
            ]
          },
          "fields": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "title": "Fields",
            "description": "Fields with values which will be investigated (e.g. title, collection name, metadata) whether they look like fake .eth ENS name. `title` key is mandatory, for ENS contracts it should be the ENS name."
          }
        },
        "type": "object",
        "required": ["network_name", "contract_address", "token_id", "fields"],
        "title": "FakeETHNameCheckFieldsRequest"
      },
      "FakeEthNameCheckResult": {
        "properties": {
          "status": {
            "$ref": "#/components/schemas/FakeEthNameCheckStatus"
          },
          "nameguard_result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/NameGuardReport"
              },
              {
                "type": "null"
              }
            ],
            "description": "NameGuard report for the .eth ENS NFT.\n* `null` if `status` is any value except `authentic_eth_name`, `invalid_eth_name` and `unknown_eth_name` (the NFT is not associated with authentic \".eth\" contracts)"
          },
          "investigated_fields": {
            "anyOf": [
              {
                "additionalProperties": {
                  "type": "string"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Investigated Fields",
            "description": "Fields with values from Alchemy response which are investigated (e.g. title, collection name, metadata) whether they look like fake .eth ENS name.\n* `null` if `status` is `unknown_nft`"
          }
        },
        "type": "object",
        "required": ["status", "nameguard_result", "investigated_fields"],
        "title": "FakeEthNameCheckResult",
        "description": "Fake .eth ENS name check result."
      },
      "FakeEthNameCheckStatus": {
        "type": "string",
        "enum": [
          "authentic_eth_name",
          "impersonated_eth_name",
          "potentially_impersonated_eth_name",
          "non_impersonated_eth_name",
          "unknown_nft",
          "invalid_eth_name",
          "unknown_eth_name"
        ],
        "title": "FakeEthNameCheckStatus",
        "description": "* `authentic_eth_name` The NFT is associated with authentic \".eth\" contracts.\n* `impersonated_eth_name` The NFT appears to impersonate a \".eth\" name. It doesn't belong to authentic ENS contracts but contains graphemes that visually resemble \".eth\" at the end of relevant NFT metadata fields. Consider automated rejection of this NFT from marketplaces.\n* `potentially_impersonated_eth_name` The NFT potentially impersonates a \".eth\" name. It doesn't belong to authentic ENS contracts but contains graphemes that visually resemble \".eth\" within relevant NFT metadata fields (but not at the end of those fields). Consider manual review of this NFT before publishing to marketplaces.\n* `non_impersonated_eth_name` The NFT doesn't represent itself as a \".eth\" name and doesn't belong to authentic ENS contracts. No string that visually resembles \".eth\" was found within relevant NFT metadata fields.\n* `unknown_nft`: No information could be found on the requested NFT. This generally indicates that the NFT doesn't exist or hasn't been indexed yet.\n* `invalid_eth_name`: The NFT is associated with authentic \".eth\" contracts, but it is unnormalized.\n* `potentially_authentic_eth_name`: The NFT is associated with authentic \".eth\" contracts, but its label is unknown.\n* `unknown_eth_name`: The NFT is associated with authentic \".eth\" contracts, but its label is unknown or has never been registered."
      },
      "GenericCheckResult": {
        "properties": {
          "check": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Check"
              }
            ],
            "examples": ["confusables"]
          },
          "status": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CheckStatus"
              }
            ],
            "examples": ["warn"]
          },
          "message": {
            "type": "string",
            "title": "Message",
            "description": "A message describing the result of the check.",
            "readOnly": true
          },
          "check_name": {
            "type": "string",
            "title": "Check Name",
            "description": "The human-readable name of the check.",
            "readOnly": true
          }
        },
        "type": "object",
        "required": ["check", "status", "message", "check_name"],
        "title": "GenericCheckResult",
        "description": "The result of a conducted check."
      },
      "GraphemeGuardReport": {
        "properties": {
          "rating": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Rating"
              }
            ],
            "examples": ["warn"]
          },
          "risk_count": {
            "type": "integer",
            "title": "Risk Count",
            "description": "The number of checks that have a status of `alert` or `warn`.",
            "examples": [2]
          },
          "highest_risk": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GenericCheckResult"
              },
              {
                "type": "null"
              }
            ],
            "description": "The check considered to be the highest risk. If no check has a status of `alert` or `warn`, this field is `null`."
          },
          "normalization": {
            "$ref": "#/components/schemas/GraphemeNormalization"
          },
          "grapheme": {
            "type": "string",
            "title": "Grapheme",
            "description": "The analyzed grapheme.",
            "examples": ["v"]
          },
          "grapheme_name": {
            "type": "string",
            "title": "Grapheme Name",
            "description": "The name of the grapheme.",
            "examples": ["Latin Small Letter V"]
          },
          "grapheme_type": {
            "type": "string",
            "title": "Grapheme Type",
            "description": "The type of the grapheme. If all characters in the grapheme have the same type, that type is returned. Otherwise, `special` is returned.\n* `simple_letter` - `[a-z]`\n* `simple_number` - `[0-9]`\n* `other_letter` - a letter (single-char grapheme) in any script that is not simple; `LC` class http://www.unicode.org/reports/tr44/#GC_Values_Table \n* `other_number` - a digit (single-char grapheme) in any script that is not simple; `N` class http://www.unicode.org/reports/tr44/#GC_Values_Table \n* `hyphen` - a hyphen\n* `dollarsign` - a dollar sign\n* `underscore` - an underscore\n* `emoji` - an emoji or emoji ZWJ sequence\n* `invisible` - zero width joiner or non-joiner\n* `special` - for any grapheme that doesn't match one of the other classifications or if characters have different types",
            "examples": ["simple_letter"]
          },
          "grapheme_script": {
            "type": "string",
            "title": "Grapheme Script",
            "description": "Script name of the grapheme computed from the script names of its characters.",
            "examples": ["Latin"]
          },
          "grapheme_description": {
            "type": "string",
            "title": "Grapheme Description",
            "description": "Description of the grapheme type.",
            "examples": ["A-Z letter"]
          },
          "checks": {
            "items": {
              "$ref": "#/components/schemas/GenericCheckResult"
            },
            "type": "array",
            "title": "Checks",
            "description": "A list of checks that were performed on the grapheme."
          },
          "grapheme_link": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Grapheme Link",
            "description": "Link to an external page with information about the grapheme.\n* `null` for multi-character graphemes",
            "examples": ["https://unicodeplus.com/U+0076"]
          },
          "confusables": {
            "items": {
              "$ref": "#/components/schemas/ConfusableGuardReport"
            },
            "type": "array",
            "title": "Confusables",
            "description": "A list graphemes that can be confused with the analyzed grapheme. The list does not contain the analyzed grapheme. A canonical form of the grapheme is the first element of the list, if it is known. Otherwise, the first element is a different confusable."
          },
          "canonical_grapheme": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Canonical Grapheme",
            "description": "A grapheme that is the canonical form of the analyzed grapheme.\n* `null` if the canonical form is not known\n* does not imply that the canonical grapheme/label/name is normalized",
            "examples": ["v"]
          },
          "title": {
            "type": "string",
            "title": "Title",
            "description": "A human-readable title based on the `rating`.",
            "readOnly": true
          },
          "subtitle": {
            "type": "string",
            "title": "Subtitle",
            "description": "A human-readable subtitle based on the `rating`.",
            "readOnly": true
          },
          "grapheme_link_name": {
            "type": "string",
            "title": "Grapheme Link Name",
            "description": "The name of the webpage that `grapheme_link` links to.\n* \"No link is available\" if `grapheme_link` is `null`",
            "readOnly": true
          },
          "codepoints": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Codepoints",
            "description": "The codepoints of the grapheme in the format `U+XXXX`. Some graphemes may have multiple codepoints.",
            "readOnly": true
          }
        },
        "type": "object",
        "required": [
          "rating",
          "risk_count",
          "highest_risk",
          "normalization",
          "grapheme",
          "grapheme_name",
          "grapheme_type",
          "grapheme_script",
          "grapheme_description",
          "checks",
          "grapheme_link",
          "confusables",
          "canonical_grapheme",
          "title",
          "subtitle",
          "grapheme_link_name",
          "codepoints"
        ],
        "title": "GraphemeGuardReport"
      },
      "GraphemeNormalization": {
        "type": "string",
        "enum": ["normalized", "unnormalized"],
        "title": "GraphemeNormalization",
        "description": "The ENSIP-15 normalization status of a grapheme.\nThis check does not consider the context of the grapheme and is **not** equivalent to `ens_normalize(grapheme)`.\nA normalized grapheme can be combined with other normalized graphemes to form an unnormalized label.\nThe position of a grapheme in a label can also affect the normalization status of the label.\n\n* `normalized`: The grapheme is normalized.\n* `unnormalized`: The grapheme is not normalized."
      },
      "HTTPValidationError": {
        "properties": {
          "detail": {
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            },
            "type": "array",
            "title": "Detail"
          }
        },
        "type": "object",
        "title": "HTTPValidationError"
      },
      "ImpersonationStatus": {
        "type": "string",
        "enum": ["unlikely", "potential"],
        "title": "ImpersonationStatus",
        "description": "The predicted impersonation status of an ENS name.\n\n* `unlikely`: The ENS name is unlikely to be impersonating.\n* `potential`: The ENS name is potentially impersonating."
      },
      "InspectLabelhashRequest": {
        "properties": {
          "labelhash": {
            "type": "string",
            "title": "Labelhash",
            "description": "Labelhash should be a decimal or a hex (prefixed with 0x) string.",
            "examples": [
              "0x3276e4878615389906712b876ce1455b8f5d1c5ea3ffcf7a705e0d32fafae9c5"
            ]
          },
          "network_name": {
            "$ref": "#/components/schemas/NetworkName"
          },
          "parent_name": {
            "type": "string",
            "title": "Parent Name",
            "default": "eth"
          }
        },
        "type": "object",
        "required": ["labelhash", "network_name"],
        "title": "InspectLabelhashRequest"
      },
      "InspectNameRequest": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Name to inspect.",
            "examples": ["vitalìk.eth"]
          },
          "network_name": {
            "$ref": "#/components/schemas/NetworkName"
          }
        },
        "type": "object",
        "required": ["name", "network_name"],
        "title": "InspectNameRequest"
      },
      "InspectNamehashRequest": {
        "properties": {
          "namehash": {
            "type": "string",
            "title": "Namehash",
            "description": "Namehash should be a decimal or a hex (prefixed with 0x) string.",
            "examples": [
              "0xd48fd5598e605861cbd8e45419b41b83739bff52eaef0e283181bbe0a43a5b32"
            ]
          },
          "network_name": {
            "$ref": "#/components/schemas/NetworkName"
          }
        },
        "type": "object",
        "required": ["namehash", "network_name"],
        "title": "InspectNamehashRequest"
      },
      "LabelGuardReport": {
        "properties": {
          "rating": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Rating"
              }
            ],
            "examples": ["warn"]
          },
          "risk_count": {
            "type": "integer",
            "title": "Risk Count",
            "description": "The number of checks that have a status of `alert` or `warn`.",
            "examples": [2]
          },
          "highest_risk": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GenericCheckResult"
              },
              {
                "type": "null"
              }
            ],
            "description": "The check considered to be the highest risk. If no check has a status of `alert` or `warn`, this field is `null`."
          },
          "label": {
            "type": "string",
            "title": "Label",
            "description": "The analyzed label. If the label is unknown, this field is `[labelhash]`.",
            "examples": [
              "vitalìk",
              "[99b91f5ec34a22cf0fb21c9f43be6c6417d9991e979c1dca532a8e74d1feec23]"
            ]
          },
          "labelhash": {
            "type": "string",
            "title": "Labelhash",
            "description": "The labelhash of the label in hex format prefixed with `0x`.",
            "examples": [
              "0x41459971a5b847d0eef67bc11e2845f1074a2aed1ac6a357378b18fba50816e4"
            ]
          },
          "normalization": {
            "$ref": "#/components/schemas/Normalization"
          },
          "checks": {
            "items": {
              "$ref": "#/components/schemas/GenericCheckResult"
            },
            "type": "array",
            "title": "Checks",
            "description": "A list of checks that were performed on the label."
          },
          "graphemes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/ConsolidatedGraphemeGuardReport"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Graphemes",
            "description": "A list of graphemes that were analyzed in the label. If the label is unknown, this field is `null`."
          },
          "canonical_label": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Canonical Label",
            "description": "The canonical form of the analyzed label.\n* `null` if the canonical form of any grapheme is not known\n* `null` if the result would be unnormalized, even if the canonical form of all graphemes is known\n* `[labelhash]` if the label is unknown",
            "examples": ["vitalik"]
          },
          "title": {
            "type": "string",
            "title": "Title",
            "description": "A human-readable title based on the `rating`.",
            "readOnly": true
          },
          "subtitle": {
            "type": "string",
            "title": "Subtitle",
            "description": "A human-readable subtitle based on the `rating`.",
            "readOnly": true
          },
          "beautiful_label": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Beautiful Label",
            "description": "Beautified version of `label`.",
            "readOnly": true
          }
        },
        "type": "object",
        "required": [
          "rating",
          "risk_count",
          "highest_risk",
          "label",
          "labelhash",
          "normalization",
          "checks",
          "graphemes",
          "canonical_label",
          "title",
          "subtitle",
          "beautiful_label"
        ],
        "title": "LabelGuardReport",
        "description": "Label analysis result."
      },
      "NameGuardReport": {
        "properties": {
          "rating": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Rating"
              }
            ],
            "examples": ["warn"]
          },
          "risk_count": {
            "type": "integer",
            "title": "Risk Count",
            "description": "The number of checks that have a status of `alert` or `warn`.",
            "examples": [2]
          },
          "highest_risk": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GenericCheckResult"
              },
              {
                "type": "null"
              }
            ],
            "description": "The check considered to be the highest risk. If no check has a status of `alert` or `warn`, this field is `null`."
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "The analyzed name. Can contain labelhashes when some labels are unknown.",
            "examples": [
              "vitalìk.eth",
              "[af498306bb191650e8614d574b3687c104bc1cd7e07c522954326752c6882770].eth"
            ]
          },
          "namehash": {
            "type": "string",
            "title": "Namehash",
            "description": "The namehash of the name in hex format prefixed with `0x`.",
            "examples": [
              "0xd48fd5598e605861cbd8e45419b41b83739bff52eaef0e283181bbe0a43a5b32"
            ]
          },
          "normalization": {
            "$ref": "#/components/schemas/Normalization"
          },
          "checks": {
            "items": {
              "$ref": "#/components/schemas/GenericCheckResult"
            },
            "type": "array",
            "title": "Checks",
            "description": "A list of checks that were performed on the name."
          },
          "labels": {
            "items": {
              "$ref": "#/components/schemas/LabelGuardReport"
            },
            "type": "array",
            "title": "Labels",
            "description": "The analyzed labels of the name."
          },
          "canonical_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Canonical Name",
            "description": "The canonical form of the analyzed name.\n* `null` if the canonical form of any label is not known\n* `can contain labelhashes when some labels are unknown`",
            "examples": ["vitalik.eth"]
          },
          "title": {
            "type": "string",
            "title": "Title",
            "description": "A human-readable title based on the `rating`.",
            "readOnly": true
          },
          "subtitle": {
            "type": "string",
            "title": "Subtitle",
            "description": "A human-readable subtitle based on the `rating`.",
            "readOnly": true
          },
          "beautiful_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Beautiful Name",
            "description": "Beautified version of `name`.",
            "readOnly": true
          }
        },
        "type": "object",
        "required": [
          "rating",
          "risk_count",
          "highest_risk",
          "name",
          "namehash",
          "normalization",
          "checks",
          "labels",
          "canonical_name",
          "title",
          "subtitle",
          "beautiful_name"
        ],
        "title": "NameGuardReport",
        "description": "Full name analysis result with information about individual checks and labels."
      },
      "NetworkName": {
        "type": "string",
        "enum": ["mainnet", "sepolia", "goerli"],
        "title": "NetworkName"
      },
      "Normalization": {
        "type": "string",
        "enum": ["normalized", "unnormalized", "unknown"],
        "title": "Normalization",
        "description": "The ENSIP-15 normalization status of a name or label.\n\n* `normalized`: The name or label is normalized.\n* `unnormalized`: The name or label is not normalized.\n* `unknown`: The name or label is unknown because it cannot be looked up from its hash."
      },
      "Rating": {
        "type": "string",
        "enum": ["pass", "warn", "alert"],
        "title": "Rating",
        "description": "The rating of a name/label/grapheme based on multiple conducted checks.\n\n* `pass`: All checks passed.\n* `warn`: At least one check failed with a `WARN` status but no check failed with an `ALERT` status.\n* `alert`: At least one check failed with an `ALERT` status."
      },
      "SecurePrimaryNameResult": {
        "properties": {
          "primary_name_status": {
            "$ref": "#/components/schemas/SecurePrimaryNameStatus"
          },
          "impersonation_status": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ImpersonationStatus"
              },
              {
                "type": "null"
              }
            ],
            "description": "Impersonation status of the `primary_name`.\n* `null` if `primary_name` is `null`"
          },
          "primary_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Primary Name",
            "description": "Primary ENS name for the Ethereum address.\n* `null` if `primary_name_status` is any value except `normalized`",
            "examples": ["vitalik.eth"]
          },
          "display_name": {
            "type": "string",
            "title": "Display Name",
            "description": "ENS beautified version of `primary_name`.\n* if `primary_name` is `null` then provides a fallback `display_name` of \"Unnamed [first four hex digits of Ethereum address]\", e.g. \"Unnamed c2a6\"",
            "examples": ["vitalik.eth"]
          },
          "nameguard_result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/NameGuardReport"
              },
              {
                "type": "null"
              }
            ],
            "description": "NameGuard report for the `primary_name`.\n* `null` if `primary_name_status` is `no_primary_name` (primary name is not found)"
          }
        },
        "type": "object",
        "required": [
          "primary_name_status",
          "impersonation_status",
          "primary_name",
          "display_name",
          "nameguard_result"
        ],
        "title": "SecurePrimaryNameResult",
        "description": "Reverse lookup result."
      },
      "SecurePrimaryNameStatus": {
        "type": "string",
        "enum": ["normalized", "no_primary_name", "unnormalized"],
        "title": "SecurePrimaryNameStatus",
        "description": "The status of a secure primary ENS name lookup performed by NameGuard.\n\n* `normalized`: The ENS primary name was found and it is normalized.\n* `no_primary_name`: The ENS primary name was not found.\n* `unnormalized`: The ENS primary name was found, but it is not normalized."
      },
      "ValidationError": {
        "properties": {
          "loc": {
            "items": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ]
            },
            "type": "array",
            "title": "Location"
          },
          "msg": {
            "type": "string",
            "title": "Message"
          },
          "type": {
            "type": "string",
            "title": "Error Type"
          }
        },
        "type": "object",
        "required": ["loc", "msg", "type"],
        "title": "ValidationError"
      }
    }
  }
}
